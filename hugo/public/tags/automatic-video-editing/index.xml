<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>automatic-video-editing | David Bieber</title>
    <link>https://davidbieber.com/tags/automatic-video-editing/</link>
      <atom:link href="https://davidbieber.com/tags/automatic-video-editing/index.xml" rel="self" type="application/rss+xml" />
    <description>automatic-video-editing</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><lastBuildDate>Tue, 05 Jan 2021 00:00:00 +0000</lastBuildDate>
    <image>
      <url>img/map[gravatar:%!s(bool=true) shape:circle]</url>
      <title>automatic-video-editing</title>
      <link>https://davidbieber.com/tags/automatic-video-editing/</link>
    </image>
    
    <item>
      <title>ffmpeg aspirations</title>
      <link>https://davidbieber.com/snippets/2021-01-05-ffmpeg-aspirations/</link>
      <pubDate>Tue, 05 Jan 2021 00:00:00 +0000</pubDate>
      <guid>https://davidbieber.com/snippets/2021-01-05-ffmpeg-aspirations/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;turn a collection of photos into a slide show&lt;/li&gt;
&lt;li&gt;set it to music&lt;/li&gt;
&lt;li&gt;add gentle transitions, like a slow pan of the camera&lt;/li&gt;
&lt;li&gt;fade the music in and out to change songs&lt;/li&gt;
&lt;li&gt;given a file of time stamp ranges, clip to just those parts of the file&lt;/li&gt;
&lt;li&gt;given a file of timestamp ranges, each with a speed multiplier, adjust the speed of each clip and stitch together the clips&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I have code that does this last one already, but I suspect it can be orders of magnitude faster done as an ffmpeg command compared with the way I&amp;rsquo;m doing it now.&lt;/p&gt;
&lt;h2 id=&#34;turn-a-collection-of-photos-into-a-slide-show&#34;&gt;Turn a collection of photos into a slide show:&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ffmpeg \
  -r 1/5 \
  -pattern_type glob -i &amp;quot;/Users/dbieber/Documents/video/raw/*.png&amp;quot; \
  -c:v libx264 \
  -r 30 \
  -pix_fmt yuv420p \
  output.mp4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Next up, I&amp;rsquo;ll see if I can add some audio, and I&amp;rsquo;ll work my way down the list.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Tips for Effective OBS</title>
      <link>https://davidbieber.com/snippets/2020-04-11-tips-for-obs/</link>
      <pubDate>Sat, 11 Apr 2020 00:00:00 +0000</pubDate>
      <guid>https://davidbieber.com/snippets/2020-04-11-tips-for-obs/</guid>
      <description>&lt;p&gt;As a newcomer to OBS, I&amp;rsquo;ve been regularly discovering new features that make my OBS experience better. Here are a handful of things I&amp;rsquo;ve found useful, that perhaps weren&amp;rsquo;t immediately obvious to me, from my early experiences with OBS.&lt;/p&gt;
&lt;h2 id=&#34;using-media-sources&#34;&gt;Using Media Sources&lt;/h2&gt;
&lt;p&gt;&amp;ldquo;Media Source&amp;rdquo; video sources are essential when showing prerecorded video, or using a replay buffer. However, it wasn&amp;rsquo;t obvious to me how to get media sources to play their audio.&lt;/p&gt;
&lt;p&gt;When using a Media Source, here&amp;rsquo;s out to turn on the audio. In the Audio Mixer panel choose &lt;code&gt;Gear Settings &amp;gt; Advanced Audio Properties&lt;/code&gt; then set &lt;code&gt;Audio Monitoring&lt;/code&gt; to &amp;ldquo;Monitor and Output&amp;rdquo;.&lt;/p&gt;
&lt;h2 id=&#34;namespaces-for-scenes--turning-off-the-camera&#34;&gt;Namespaces for Scenes + Turning Off the Camera&lt;/h2&gt;
&lt;p&gt;You can create multiple Profiles and Scene Collections in OBS. I only have one Profile, which I&amp;rsquo;ve named &amp;ldquo;Default&amp;rdquo; (rather than the default of &amp;ldquo;Untitled&amp;rdquo;). I made a few Scene Collections. Making new Scene Collections gives you a space to play around with new ideas for scenes and keyboard shortcuts, without disrupting the main setup(s) that you&amp;rsquo;ve put together. I like to fiddle around with new ideas in a Scene Collection I&amp;rsquo;ve named &amp;ldquo;Playground&amp;rdquo;.&lt;/p&gt;
&lt;p&gt;If you have any sources in a Scene Collection that use your webcam, then your webcam will stay on even when it isn&amp;rsquo;t being used. If you switch to a Scene Collection with no sources using your webcam, then your webcam will turn off. I use a Scene Collection that leaves my webcam off by default, and only switch to a Scene Collection with a webcam source when I actually intend to record something that needs the webcam.&lt;/p&gt;
&lt;h2 id=&#34;replay-buffer&#34;&gt;Replay Buffer&lt;/h2&gt;
&lt;p&gt;I leave the replay buffer on in between recording scenes. By setting the replay buffer to a reasonable size like 60 seconds, I can leave it rolling without consuming too much memory (and the CPU consumption has been reasonable too, e.g. 10%). This way, if anything noteworthy happens in this period between recordings, I can still capture it.&lt;/p&gt;
&lt;h2 id=&#34;virtual-cameras&#34;&gt;Virtual Cameras&lt;/h2&gt;
&lt;p&gt;If you&amp;rsquo;re willing to get your hands dirty, the instructions at 
&lt;a href=&#34;https://github.com/johnboiles/obs-mac-virtualcam&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;johnboiles/obs-mac-virtualcam&lt;/a&gt; will let you use OBS as a virtual camera on Mac.&lt;/p&gt;
&lt;h2 id=&#34;transform-editing-and-scene-json-files&#34;&gt;Transform Editing and Scene &lt;code&gt;.json&lt;/code&gt; files&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;cmd-e&lt;/code&gt; opens the Scene Item Transform for a Scene Item. Using that, you can get pixel perfect positioning of any video source. You can also see and edit the json files that describe your scenes. On Mac, these scene json files can be found at &lt;code&gt;~/Library/Application Support/obs-studio/basic/scenes&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&#34;keyboard-shortcuts&#34;&gt;Keyboard Shortcuts&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;cmd-,&lt;/code&gt; opens your settings. There&amp;rsquo;s a panel for setting keyboard shortcuts. This is a core OBS feature, and it&amp;rsquo;s extremely valuable. I really appreciate how easy OBS has made it to set up these keyboard shortcuts for switching between scenes, starting and stopping recordings, pausing and playing media, etc. I only wish I could have extra modifier keys so I could set up more shortcuts that don&amp;rsquo;t collide with the shortcuts of my IDE!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Exploring OBS and Virtual Cameras</title>
      <link>https://davidbieber.com/snippets/2020-04-09-exploring-obs/</link>
      <pubDate>Thu, 09 Apr 2020 00:00:00 +0000</pubDate>
      <guid>https://davidbieber.com/snippets/2020-04-09-exploring-obs/</guid>
      <description>&lt;p&gt;This week I&amp;rsquo;ve been exploring 
&lt;a href=&#34;https://obsproject.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;em&gt;Open Broadcasting Software&lt;/em&gt; (OBS)&lt;/a&gt; and toying with using it as a virtual camera. I use a Mac, and historically there hasn&amp;rsquo;t been a good way to use OBS as a virtual camera. With 
&lt;a href=&#34;https://twitter.com/tobi&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;@tobi&lt;/a&gt;&amp;rsquo;s recent 
&lt;a href=&#34;https://github.com/obsproject/obs-studio/issues/2568&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;$10,000 bounty&lt;/a&gt; for making this a core feature, however, some developers in the OBS community leapt into action and a 
&lt;a href=&#34;https://github.com/johnboiles/obs-mac-virtualcam&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;working prototype&lt;/a&gt; of the feature was available on GitHub within days.&lt;/p&gt;
&lt;h2 id=&#34;virtual-cameras&#34;&gt;Virtual Cameras&lt;/h2&gt;
&lt;p&gt;OBS is popular software among Twitch streamers. It lets you take a bunch of video sources and rearrange them into scenes. Streamers will often overlay a camera feed of their head and a live stream of a video game, maybe with cool graphics overlaid on the whole thing.&lt;/p&gt;
&lt;p&gt;For years, OBS has let you take the scenes you create and stream them in real time to YouTube Live or Twitch or any number of other streaming services. If you wanted to use your OBS scene in Zoom or Google Meet, however, it wasn&amp;rsquo;t straightforward, at least on Mac.&lt;/p&gt;
&lt;p&gt;There were workarounds. You could project your scene to an external monitor, and then use screen sharing to share that. At times there were combinations of tools and plugins that could similarly get the job done.&lt;/p&gt;
&lt;p&gt;Now, however, it&amp;rsquo;s considerably easier. John Boiles&amp;rsquo;s has made a OBS plugin that works without fuss. For now it still requires a technical background to use, following build instructions and executing commands on the terminal to get it set up. In a matter of months, however, I expect it will make its way as a core feature into OBS.&lt;/p&gt;
&lt;h2 id=&#34;combining-obs-with-auto-video-editing&#34;&gt;Combining OBS with Auto Video Editing&lt;/h2&gt;
&lt;p&gt;As you may know, I&amp;rsquo;ve been working on 
&lt;a href=&#34;https://davidbieber.com/snippets/2020-02-21-jump-cut-programming&#34;&gt;automatic&lt;/a&gt; 
&lt;a href=&#34;https://davidbieber.com/snippets/2020-02-26-video-tooling-progress&#34;&gt;video&lt;/a&gt; 
&lt;a href=&#34;https://davidbieber.com/snippets/2020-03-02-fastbook&#34;&gt;editing&lt;/a&gt; software. I&amp;rsquo;d like to be able to make quality content &amp;ndash; e.g. videos teaching interesting aspects of programming &amp;ndash; without needing to spend time on the video editing process. The cutting and rearranging would happen automatically. The music and audio adjustments would be added automatically. All I&amp;rsquo;d need to do is write a script and record the footage, and the auto editor would take care of the rest.&lt;/p&gt;
&lt;p&gt;Originally I was using Mac&amp;rsquo;s cmd-shift-5 screen capture capability to create these recordings. OBS lets you rearrange video feeds deliberately and use a variety of video sources. These video sources include window captures, cameras, and prerecorded media. The result is much more flexible than Mac&amp;rsquo;s screen capture, and so I&amp;rsquo;ve switched my auto video editing software over to use OBS for recording.&lt;/p&gt;
&lt;p&gt;As an aside, I&amp;rsquo;ve also discovered 
&lt;a href=&#34;https://obsproject.com/forum/resources/obs-ndi-newtek-ndi%E2%84%A2-integration-into-obs-studio.528/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;NDI&lt;/a&gt;, a plugin for OBS. It lets me use my phone&amp;rsquo;s camera as a video source with minimal setup. It was so easy to get working, in fact, that I&amp;rsquo;m convinced it must be a large security vulnerability to use it at all.&lt;/p&gt;
&lt;p&gt;Now that I&amp;rsquo;m using OBS to record, I enabled my auto video editing software to run automatically on any recording produced by OBS. As soon as the recording gets saved, my software starts editing it automatically (preserving the original). I&amp;rsquo;d love to have my auto editing start even sooner than that though, &lt;em&gt;before&lt;/em&gt; the recording is complete. The OBS codebase is surprisingly approachable, so I may be able to get this working.&lt;/p&gt;
&lt;h2 id=&#34;hacking-on-the-obs-codebase&#34;&gt;Hacking on the OBS Codebase&lt;/h2&gt;
&lt;p&gt;When John Boiles released the Mac Virtual Cam plugin for OBS, it was initially stuck on the wrong resolution. John told me it was hard coded to 720x480, and that was the impetus for me to poke at the code. Changing the hard coded resolution proved easy enough. Then I ran into a bug where OBS would fail to capture a window if I changed tabs in that window while OBS was closed. Though there&amp;rsquo;s inertia with entering any unfamiliar codebase, I found I was able to solve this issue for myself too. Through these two debugging experiences I got enough glimpses of the OBS plugin set up to think that OBS really is approachably hackable. I think, with hard work, I could integrate my auto editing code into OBS so that it runs in real time. It&amp;rsquo;s not the very top of my todo list for the auto video editor, but I&amp;rsquo;m excited to give this a try.&lt;/p&gt;
&lt;h2 id=&#34;replay-buffers-in-obs&#34;&gt;Replay Buffers in OBS&lt;/h2&gt;
&lt;p&gt;One neat feature in OBS is its ability to record a &amp;ldquo;replay buffer&amp;rdquo;. I have it set up to record a circular buffer of the last 60 seconds of content. That means that at any given moment, OBS has recorded the previous 60 seconds of footage. Unsaved footage older than 60 seconds is gone, but at any point, if I choose to save it, I can record the previous 60 seconds of footage.&lt;/p&gt;
&lt;p&gt;This is great because it means I can keep the camera rolling between scenes without wasting memory, and if anything noteworthy happens in that time I can capture it.&lt;/p&gt;
&lt;p&gt;There&amp;rsquo;s a second reason I&amp;rsquo;m excited about the replay buffer though; it may enable me to use auto-edited videos in conversations in &lt;em&gt;real time&lt;/em&gt;. I imagine the user experience like this:
I&amp;rsquo;m in a remote meeting and we&amp;rsquo;re having a discussion. By default I&amp;rsquo;m unmuted and people can hear what I&amp;rsquo;m saying. Whenever I hold down a keyboard shortcut, I&amp;rsquo;m muted in the call and OBS starts recording me. When I release the shortcut, I can continue to talk in the call. Once I&amp;rsquo;ve recorded a satisfactory amount of content for OBS, the auto-editing will be applied and I can use OBS as a virtual camera to send that recorded and edited content to my colleagues in the meeting.&lt;/p&gt;
&lt;h2 id=&#34;looking-forward&#34;&gt;Looking Forward&lt;/h2&gt;
&lt;p&gt;I&amp;rsquo;m excited to become more proficient using OBS, and to explore the various plugins and overlays that streamers use with OBS. Particularly I&amp;rsquo;m excited to look into the 
&lt;a href=&#34;https://obsproject.com/forum/resources/vst-plugins.848/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;audio plugins&lt;/a&gt; that are available.&lt;/p&gt;
&lt;p&gt;I also intend to continue my auto-editing plans from before: I&amp;rsquo;m still looking forward to introducing a &amp;ldquo;script&amp;rdquo; with audio auto-transcribed and key events entered via keyboard shortcuts and auto-tracked file saves. And I still want to be able to modify this script to automatically edit the video based on the modifications.&lt;/p&gt;
&lt;p&gt;Having explored OBS for a little while now, I&amp;rsquo;m also looking forward to integrating my auto-video editing more closely with OBS, ideally resulting in real time auto editing in the end. Here&amp;rsquo;s to hoping OBS continues to feel approachably hackable!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Fastbook: Listen to Audiobooks Faster</title>
      <link>https://davidbieber.com/snippets/2020-03-02-fastbook/</link>
      <pubDate>Mon, 02 Mar 2020 00:00:00 +0000</pubDate>
      <guid>https://davidbieber.com/snippets/2020-03-02-fastbook/</guid>
      <description>&lt;p&gt;Aaron Mayer 
&lt;a href=&#34;https://medium.com/100audiobooks/the-100-audiobook-challenge-terms-and-conditions-455c7e9409aa&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;aims to listen to 100 audiobooks in a single month&lt;/a&gt;. He intends to listen to these audiobooks at 2x - 3x speed. Intense!&lt;/p&gt;
&lt;p&gt;For the last few weeks, I&amp;rsquo;ve been working on 
&lt;a href=&#34;https://davidbieber.com/snippets/2020-02-21-jump-cut-programming/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;automatic video&lt;/a&gt; 
&lt;a href=&#34;https://davidbieber.com/snippets/2020-02-26-video-tooling-progress/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;editing tools&lt;/a&gt;. And one of the core features I&amp;rsquo;ve been working with is 
&lt;a href=&#34;https://github.com/carykh/jumpcutter/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;automatic speed adjustments to videos&lt;/a&gt; to eliminate silent airtime and make the videos more engaging. This seems like a perfect fit for Aaron&amp;rsquo;s challenge.&lt;/p&gt;
&lt;p&gt;I&amp;rsquo;ve adapted this tooling into a new tool I&amp;rsquo;m calling 
&lt;a href=&#34;https://gist.github.com/dbieber/98f909640773b5b0a0fe5696da369a1b&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Fastbook&lt;/a&gt;. It accepts audiobooks in the form of &lt;code&gt;.wav&lt;/code&gt; files, and can apply speed adjustments to the silence and the spoken word independently, even removing silence entirely if desired.&lt;/p&gt;
&lt;p&gt;If Aaron can already comfortably (with great focus) listen to a book at 2.5x speed, he can listen to a 10 hour book in 4 hours. If 20% of that book is actually silence, then the 10 hour book becomes an 8 hour book with silence removed, and the total listen time drops to just 3h12. I think 20% may actually be a conservative estimate for silent time, though it will vary from narrator to narrator.&lt;/p&gt;
&lt;p&gt;Estimating 45 minutes saved per book, this tool can save over 3 days total time across 100 books. Or, alternatively, Aaron could drop the playback speed down from 2.5x to 2x without increasing his total listening time at all, but potentially helping out his comprehension substantially.&lt;/p&gt;
&lt;p&gt;This tool wont be appropriate for all audiobook listeners. For many, the silences matter, and removing them would degrade the quality of the book. For many, listening at 2.5x would also degrade the quality of the book. So use this tool with caution.&lt;/p&gt;
&lt;p&gt;For those of you who are intersted, however, here&amp;rsquo;s how to use Fastbook.&lt;/p&gt;
&lt;h2 id=&#34;installing-fastbook&#34;&gt;Installing Fastbook&lt;/h2&gt;
&lt;p&gt;I&amp;rsquo;ve made Fastbook available for free on GitHub. You can 
&lt;a href=&#34;https://gist.github.com/dbieber/98f909640773b5b0a0fe5696da369a1b&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;access it here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;To use it, save it to your computer as &lt;code&gt;fastbook.py&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Next, make sure you have all the dependencies installed. See the dependencies section for what is required.&lt;/p&gt;
&lt;h2 id=&#34;pre-work-converting-your-book-to-wav&#34;&gt;Pre-work: Converting Your Book to &lt;code&gt;.wav&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;You need your audiobook in wav format to use Fastbook.&lt;/p&gt;
&lt;p&gt;To convert an audiobook to wav, use 
&lt;a href=&#34;https://www.ffmpeg.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ffmpeg&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Install ffmpeg. Then, run &lt;code&gt;ffmpeg -i book.aax book.wav&lt;/code&gt; to convert an Audible audiobook to a wav file. There may be an additional step if your aax file is DRM protected.&lt;/p&gt;
&lt;h2 id=&#34;using-fastbook&#34;&gt;Using Fastbook&lt;/h2&gt;
&lt;p&gt;Now you can use Fastbook like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;python fastbook.py \
--audio_path=/path/to/book.wav \
--output_path=/path/to/book-fast.wav \
--loud_speed=1 \
--quiet_speed=5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;--audio_path&lt;/code&gt; should point to an existing wav file that you downloaded or generated in the pre-work section. &lt;code&gt;--output_path&lt;/code&gt; is the path to the file that Fastbook will generate. Finally, &lt;code&gt;--loud_speed&lt;/code&gt; is how much to speed up the normal spoke text of the book by, and &lt;code&gt;--quiet_speed&lt;/code&gt; is how much to speed up the silence in the book by. You can remove silence by setting &lt;code&gt;--quiet_speed=99999&lt;/code&gt; or any other similiarly large number.&lt;/p&gt;
&lt;h3 id=&#34;dependencies&#34;&gt;Dependencies&lt;/h3&gt;
&lt;p&gt;Here are the dependencies you need to use Fastbook.&lt;/p&gt;
&lt;p&gt;First, you need &lt;strong&gt;Python 3&lt;/strong&gt;. You can follow 
&lt;a href=&#34;https://realpython.com/installing-python/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;these instructions&lt;/a&gt; to set up Python 3 if you don&amp;rsquo;t already have it installed.&lt;/p&gt;
&lt;p&gt;Then, you need these Python depenencies: &lt;em&gt;fire&lt;/em&gt;, &lt;em&gt;scipy&lt;/em&gt;, &lt;em&gt;tqdm&lt;/em&gt;, &lt;em&gt;numpy&lt;/em&gt;, and &lt;em&gt;audiotsm&lt;/em&gt;. Install these with &lt;code&gt;pip install fire scipy tqdm numpy audiotsm&lt;/code&gt; or use your favorite Python package manager.&lt;/p&gt;
&lt;p&gt;Finally, to do the pre-work, you will likely need ffmpeg. Installation instructions are available 
&lt;a href=&#34;https://www.ffmpeg.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;read-quick&#34;&gt;Read quick!&lt;/h2&gt;
&lt;p&gt;I recommend for Aaron to use the default speed settings of &lt;code&gt;--loud_speed=1 --quiet_speed=5&lt;/code&gt;. This wont eliminate the silence entirely, but will reduce the audio time considerably. Then, for the remaining speed-up, I suggest using whatever media player you were already using, such as VLC which supports arbitrary speed adjustments in real time. Hpy rdng!&lt;/p&gt;
&lt;h2 id=&#34;demo&#34;&gt;Demo&lt;/h2&gt;
&lt;p&gt;This blog post, narrated slowly:&lt;/p&gt;
&lt;p&gt;&lt;audio
controls
src=&#34;https://davidbieber.com/audio/fastbook.m4a&#34;&gt;
Your browser does not support the &lt;code&gt;audio&lt;/code&gt; element.
&lt;/audio&gt;&lt;/p&gt;
&lt;p&gt;This blog post again, now with just the silence accelerated:&lt;/p&gt;
&lt;p&gt;&lt;audio
controls
src=&#34;https://davidbieber.com/audio/fastbook-fast.m4a&#34;&gt;
Your browser does not support the &lt;code&gt;audio&lt;/code&gt; element.
&lt;/audio&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Video Tooling Progress</title>
      <link>https://davidbieber.com/snippets/2020-02-26-video-tooling-progress/</link>
      <pubDate>Wed, 26 Feb 2020 00:00:00 +0000</pubDate>
      <guid>https://davidbieber.com/snippets/2020-02-26-video-tooling-progress/</guid>
      <description>&lt;p&gt;Over the last week and a half I&amp;rsquo;ve been making screen recordings of myself programming. Mostly what I&amp;rsquo;ve been programming is tooling to help myself make better screen recordings. Here&amp;rsquo;s an overview of what I&amp;rsquo;ve put together so far.&lt;/p&gt;
&lt;h2 id=&#34;auto-auto-jumpcutter&#34;&gt;Auto Auto-Jumpcutter&lt;/h2&gt;
&lt;p&gt;This springboards directly from carykh&amp;rsquo;s 
&lt;a href=&#34;https://github.com/carykh/jumpcutter&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;jumpcutter&lt;/a&gt; project, which uses 
&lt;a href=&#34;https://www.ffmpeg.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ffmpeg&lt;/a&gt; and AudioTSM to speed up the silent sections of a video. Auto Auto-Jumpcutter has two &amp;ldquo;auto&amp;quot;s in its name because jumpcutter already does automatic jumpcutting of videos, and Auto Auto-Jumpcutter uses 
&lt;a href=&#34;https://pythonhosted.org/watchdog/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;watchdog&lt;/a&gt; to automatically apply jumpcutter the moment a screen recording is captured.&lt;/p&gt;
&lt;p&gt;The result is that my typing appears superhuman in speed, but slows down while I&amp;rsquo;m speaking, without me needing to do any manual editing to the video to achieve this effect.&lt;/p&gt;
&lt;h2 id=&#34;auto-commit&#34;&gt;Auto-Commit&lt;/h2&gt;
&lt;p&gt;I also made for myself a git auto-committer. Every time I save a file during a screen recording session, the change is immediately and automatically committed. The commit message is selected automatically from the diff. The result is that I have a timestamped log of all changes made during the recording. This is super useful for editing the recordings (both automatically and manually) because I can pinpoint exactly where in the recording any change took place. It also works hand-in-hand with the next piece of tooling.&lt;/p&gt;
&lt;h2 id=&#34;keyboard-shortcuts&#34;&gt;Keyboard Shortcuts&lt;/h2&gt;
&lt;p&gt;Just using Auto Auto-Jumpcutter goes a long way toward having automatically edited videos, but it doesn&amp;rsquo;t completely eliminate the need for manual editing.
For example, it provides no way to do multiple takes and stitch together the good parts of each. For this I&amp;rsquo;ve set up a keyboard shortcut system for myself using the Python 
&lt;a href=&#34;https://pypi.org/project/keyboard/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;keyboard&lt;/a&gt; module. This way I can indicate via keyboard shortcuts to remove a selection of footage during the recording session, and have it automatically be removed during the automatic editing phase. This last step &amp;ndash; using the keyboard shortcuts to guide automatic editing &amp;ndash; is an active work in progress.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Jump-Cut Programming: Take 1</title>
      <link>https://davidbieber.com/snippets/2020-02-21-jump-cut-programming/</link>
      <pubDate>Fri, 21 Feb 2020 00:00:00 +0000</pubDate>
      <guid>https://davidbieber.com/snippets/2020-02-21-jump-cut-programming/</guid>
      <description>&lt;p&gt;I&amp;rsquo;ve been toying around with recording myself programming. Here&amp;rsquo;s a clip.&lt;/p&gt;
&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/OxsuHWVtMSM&#34; frameborder=&#34;0&#34; allow=&#34;accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture&#34; allowfullscreen&gt;&lt;/iframe&gt;
&lt;p&gt;In this clip I use 
&lt;a href=&#34;https://davidbieber.com/projects/python-fire&#34;&gt;Python Fire&lt;/a&gt; to create a simple two-function calculator. Nothing special about that.&lt;/p&gt;
&lt;p&gt;What is special is that the programming has automatically been sped up by 
&lt;a href=&#34;https://github.com/carykh/jumpcutter&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;carykh/jumpcutter&lt;/a&gt;, and that I&amp;rsquo;ve used 
&lt;a href=&#34;https://zulko.github.io/moviepy/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;moviepy&lt;/a&gt; to set the programming to the music 
&lt;a href=&#34;http://incompetech.com/music/royalty-free/index.html?isrc=USUAN1100414&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&amp;ldquo;Dangerous&amp;rdquo;&lt;/a&gt;, a clip I got from 
&lt;a href=&#34;https://www.youtube.com/audiolibrary/music&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;YouTube&amp;rsquo;s free Audio Library&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;lessons-learned-from-take-1&#34;&gt;Lessons Learned from &amp;ldquo;Take 1&amp;rdquo;&lt;/h2&gt;
&lt;h3 id=&#34;what-worked-well&#34;&gt;What worked well?&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;External Monitor&lt;/strong&gt;: I purchased an external monitor. This made a huge difference. Now I can manage video-editing tools, a terminal, a browser, etc on one screen, while keeping the contents of the video (the editor and public terminal) on the other screen and recording it.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;
&lt;a href=&#34;https://github.com/carykh/jumpcutter&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;carykh/jumpcutter&lt;/a&gt;&lt;/strong&gt;: This tool can automatically speed up the silent parts of a video, resulting in shorter less-boring videos.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Mac Screen Capture&lt;/strong&gt;: cmd-shift-5 lets you capture video on Mac. You can choose what directory the captured video is saved to. Before I discovered this, I used QuickTime, but this is easier to use.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Using 
&lt;a href=&#34;https://pythonhosted.org/watchdog/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;watchdog&lt;/a&gt;&lt;/strong&gt; This is a Python module that can monitor your filesystem and trigger an action when files are created or modified. I use it to a) automatically rename video files as they&amp;rsquo;re created, and b) to automatically apply jumpcutting to new captured videos. The filename format I use is &lt;code&gt;YYYY-MM-DD-screen-recording-###.mov&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Python Fire&lt;/strong&gt;: The first twenty clips I recorded (not released) were all of me building the tooling I now use as I record videos. Most of this tooling lives in Python Fire CLIs. These CLIs let me do things like composite audio, perform auto-jumpcutting, and rename videos.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;things-to-improve&#34;&gt;Things to improve:&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Zoom in!&lt;/strong&gt; The code is blurry and small and the video as is needs to be watched at 1080p to look OK, which is silly.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Audio Quality&lt;/strong&gt; I have a lapel mic I&amp;rsquo;m using for new recordings and it helps.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Storytelling&lt;/strong&gt; Is a Python Fire CLI for adding and subtracting the most compelling story? I think there&amp;rsquo;s room for improvement.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Manual Editing&lt;/strong&gt; I did no manual editing for the clip above. I think for quality videos, however, learning to do some manual editing is going to be essential. We&amp;rsquo;ll see how far my inclination to automate everything takes me first though.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;p&gt;I&amp;rsquo;m really enjoying this process of recording videos. And more than making the videos, I&amp;rsquo;m enjoying building the software to help me make the videos. Next step for me is getting more familiar with moviepy. And Davinci Resolve. But one thing at a time.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
